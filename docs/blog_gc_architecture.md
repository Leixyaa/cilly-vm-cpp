# 手搓 VM 复盘：从我的 C++ 并发 GC 到字节 PrimJS 的架构演进

最近一直在死磕我的 C++ 虚拟机项目 `cilly-vm-cpp` 的垃圾回收（GC）模块。从最开始的单线程“卡顿”版，一步步优化到了现在的**并行标记 (Parallel Marking)** + **并发清除 (Concurrent Sweep)**。

本来以为这个架构已经挺能打了，直到我为了寻找优化灵感，去啃了字节跳动开源的 PrimJS（Lynx 底层的 JS 引擎）的源码。这一对比，直接让我看到了“业余”和“职业”之间的鸿沟。

这篇文章既是我的学习笔记，也是一次深度的架构复盘。我会详细拆解我的实现方案，对比 PrimJS 的工业级设计，并聊聊我准备如何改进。

## 一、 我的 GC 是怎么实现的？（现状分析）

我的目标很简单：解决 Stop-The-World (STW) 带来的卡顿问题。也就是说，GC 的时候，别让主线程停太久。

为了达成这个目标，我做了两层并发优化：

### 1. 并行标记 (Parallel Marking) ―― 多人一起找对象
在“标记阶段”，我们需要遍历整个对象图，找出所有活着的对象。单线程遍历太慢了，所以我上了多线程。

*   **实现细节**：
    *   **CAS 抢占**：给每个对象加了个原子标记位。多个线程同时看到同一个对象时，用 CAS (Compare-And-Swap) 只有一个人能标记成功，防止重复处理。
    *   **全局任务栈**：搞了一个 `vector<GcObject*> global_stack`，所有线程发现新对象（子节点）后，都往这个大栈里扔；没活干了，也都从这里拿。
    *   **锁保护**：因为大家都访问同一个栈，我必须加一把 `mutex` 锁，保证数据安全。

### 2. 并发清除 (Concurrent Sweep) ―― 后台偷偷删垃圾
在“清除阶段”，我们需要把死对象 `delete` 掉。如果死对象有几万个，主线程一个个删会卡很久。

*   **实现细节**：
    *   主线程只做一件事：快速遍历链表，把死对象从链表上“摘”下来，放到一个临时列表里。
    *   然后启动一个后台线程 (`detach`)，把这个列表交给它。
    *   主线程立刻返回继续跑业务代码，后台线程在另一边慢慢 `delete` 这些垃圾。

**效果**：主线程几乎瞬间恢复响应，体验确实好了很多。

## 二、 差距在哪？深度解析 PrimJS 的架构

PrimJS 是为了解决移动端极致性能问题的，它的设计哲学完全不同。

### 1. 任务调度的瓶颈：全局锁 vs 本地队列
*   **我的问题**：
    虽然我开了多线程，但大家都在**抢同一把锁**。
    想象一下，工地上有 4 个工人，但只有 1 个铲子（全局栈）。大家大部分时间都在排队等铲子，而不是在干活。线程越多，排队越久，这就是**锁竞争 (Lock Contention)**。
*   **PrimJS 的解法**：**本地队列 (Thread-Local Queues) + 工作窃取 (Work Stealing)**。
    *   **私有化**：每个工人发一把铲子（本地队列）。我发现的新任务，直接扔进我自己的队列，**完全不需要加锁**。
    *   **互助**：只有当我自己的活干完了，我才去隔壁工人的队列里“偷”一点活过来。
    *   **优势**：99% 的时间里大家各干各的，互不干扰，性能直接拉满。

### 2. 线程模型的开销：临时工 vs 正规军
*   **我的问题**：
    我现在的做法是：每次 GC 开始，我就 `new thread` 创建线程；GC 结束，我就 `join` 销毁它们。
    这就像是每次要打扫卫生，现去人才市场招临时工，干完活立马解雇。**招人和解雇（系统调用）的成本是很高的**，而且新招的人手脚是凉的（CPU 缓存冷），热身慢。
*   **PrimJS 的解法**：**线程池 (Thread Pool)**。
    *   它养了一支“正规军”。VM 启动时线程就创建好了。
    *   没事干的时候，大家在休息室睡觉（Condition Variable Wait）。
    *   有活了，广播一声，大家立马起来干活。干完继续睡。
    *   **优势**：零启动开销，响应极快。

### 3. 对象分发的方式：虚函数 vs Tag 分发
*   **我的做法**：利用 C++ 的**虚函数** (`virtual Trace`)。
    GC 拿到一个对象，调用它的 `Trace()` 方法。对象自己知道该怎么遍历子节点。
    *   **优点**：代码极其优雅。加新类型只需要写个新类，不用改 GC 代码。
    *   **缺点**：虚函数调用有一层间接跳转，CPU 分支预测容易失败，稍微慢一点点。
*   **PrimJS 的做法**：**Tag Dispatching**。
    它给每个对象贴个标签（Tag），GC 用一个巨大的 `switch-case` 来判断类型。
    *   **优点**：极致的快，没有任何多余动作。
    *   **缺点**：代码耦合度极高，维护起来很痛苦。

## 三、 我的改进计划 (Action Plan)

看完 PrimJS，我决定对我的 VM 进行“取其精华，去其糟粕”的升级：

1.  **必须做 (Must Do)**：**引入线程池**。
    把现有的 Fork-Join 模式改成线程池模式。这个改动不算大，但能显著减少系统开销，让 GC 响应更丝滑。

2.  **必须做 (Must Do)**：**实现 Work Stealing**。
    拆掉那个全局共享栈，换成每个线程一个本地队列。这是提升并行效率的关键一步，能彻底释放多核 CPU 的潜力。

3.  **保留 (Keep)**：**坚持用虚函数**。
    PrimJS 用 switch-case 是为了榨干最后 1% 的性能，牺牲了代码可维护性。但我这是个学习型项目，代码的清晰和优雅更重要。我不想为了那一点点性能，把代码写成一坨难以维护的 switch-case。

4.  **学习但暂不落地 (Learn)**：**内存分配器**。
    PrimJS 为了极致性能，连 `malloc` 都自己重写了，直接操作内存页。这属于“屠龙技”，我现在学到了思想就好，暂时不去碰，否则容易把自己坑死在跨平台适配的泥潭里。

## 四、 总结

做系统开发就是这样，**没有绝对最好的架构，只有最适合的 Trade-off（权衡）**。

PrimJS 选择了**极致的性能和掌控**，所以它做得非常重、非常复杂。
而我的 cilly-vm-cpp 选择了**适度的性能和优秀的架构**，在保证运行流畅的同时，保持代码的整洁和可扩展性。

这次源码阅读让我明白：**所谓的“高性能”，其实就是把一个个看似微小的“锁竞争”、“内存跳转”、“系统调用”都抠到了极致。** 下一步，我也要开始“抠”我的任务调度了！
